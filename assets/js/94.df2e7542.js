(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{752:function(o,t,e){"use strict";e.r(t);var v=e(7),_=Object(v.a)({},(function(){var o=this,t=o.$createElement,e=o._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[e("p",[o._v("Spring Boot的自动配置原理是其核心机制之一，它通过“约定大于配置”的设计哲学，结合条件化装配的巧妙实现，大大简化了Spring应用的配置工作‌。")]),o._v(" "),e("p",[o._v("Spring Boot自动配置的原理可概括为：")]),o._v(" "),e("ol",[e("li",[o._v("通过"),e("code",[o._v("@EnableAutoConfiguration")]),o._v("启动自动配置流程。")]),o._v(" "),e("li",[o._v("利用"),e("code",[o._v("AutoConfigurationImportSelector")]),o._v("从约定路径加载配置类。")]),o._v(" "),e("li",[o._v("通过条件注解（"),e("code",[o._v("@Conditional")]),o._v("）动态过滤和筛选配置类。")]),o._v(" "),e("li",[o._v("最终将符合条件的配置类注入容器，完成自动装配‌。")])]),o._v(" "),e("p",[o._v("下面将详细解析其核心原理和实现机制。")]),o._v(" "),e("h2",{attrs:{id:"核心入口-enableautoconfiguration"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#核心入口-enableautoconfiguration"}},[o._v("#")]),o._v(" 核心入口："),e("code",[o._v("@EnableAutoConfiguration")])]),o._v(" "),e("p",[o._v("自动配置的入口是"),e("code",[o._v("@SpringBootApplication")]),o._v("注解中的"),e("code",[o._v("@EnableAutoConfiguration")]),o._v("。该注解通过"),e("code",[o._v("@Import")]),o._v("导入了"),e("code",[o._v("AutoConfigurationImportSelector")]),o._v("类。")]),o._v(" "),e("h2",{attrs:{id:"关键流程-autoconfigurationimportselector"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关键流程-autoconfigurationimportselector"}},[o._v("#")]),o._v(" 关键流程："),e("code",[o._v("AutoConfigurationImportSelector")])]),o._v(" "),e("h3",{attrs:{id:"getimportgroup方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#getimportgroup方法"}},[o._v("#")]),o._v(" "),e("code",[o._v("getImportGroup")]),o._v("方法")]),o._v(" "),e("p",[e("code",[o._v("AutoConfigurationImportSelector")]),o._v("实现了"),e("code",[o._v("DeferredImportSelector")]),o._v("接口而非普通的"),e("code",[o._v("ImportSelector")]),o._v("。Spring Boot会调用其"),e("code",[o._v("getImportGroup()")]),o._v("方法返回的"),e("code",[o._v("AutoConfigurationGroup")]),o._v("类，并由该类的"),e("code",[o._v("process")]),o._v("和"),e("code",[o._v("selectImports")]),o._v("方法处理自动配置类的加载，而非直接调用外部的"),e("code",[o._v("selectImports")]),o._v("方法。")]),o._v(" "),e("p",[o._v("当 Spring 容器处理 "),e("code",[o._v("@EnableAutoConfiguration")]),o._v(" 注解时，由于 "),e("code",[o._v("AutoConfigurationImportSelector")]),o._v(" 实现了 "),e("code",[o._v("DeferredImportSelector")]),o._v(" 接口，Spring 会调用其 "),e("code",[o._v("getImportGroup()")]),o._v(" 方法。该方法返回 "),e("code",[o._v("AutoConfigurationImportSelector.AutoConfigurationGroup")]),o._v(" 这个内部类的 Class 对象。")]),o._v(" "),e("p",[o._v("返回的 "),e("code",[o._v("AutoConfigurationGroup")]),o._v(" 类同样实现了 "),e("code",[o._v("DeferredImportSelector.Group")]),o._v(" 接口。Spring 随后会调用该 Group 的 process() 方法，该方法内部又通过 "),e("code",[o._v("getAutoConfigurationEntry()")]),o._v(" 来加载和筛选自动配置类。最终，Spring 通过调用 Group 的 "),e("code",[o._v("selectImports()")]),o._v(" 方法来确定并返回最终需要导入的配置类。")]),o._v(" "),e("p",[o._v("这种通过 "),e("code",[o._v("DeferredImportSelector")]),o._v(" 和其 "),e("code",[o._v("Group")]),o._v(" 机制的设计，实现了自动配置类的‌延迟加载‌。这确保了自动配置类的处理在所有用户定义的 @Configuration 类之后进行，从而为基于条件的自动配置（例如 "),e("code",[o._v("@ConditionalOnMissingBean")]),o._v("）提供了正确的判断基础。")]),o._v(" "),e("h3",{attrs:{id:"selectimports方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#selectimports方法"}},[o._v("#")]),o._v(" "),e("code",[o._v("selectImports")]),o._v("方法")]),o._v(" "),e("p",[e("code",[o._v("AutoConfigurationImportSelector")]),o._v("的"),e("code",[o._v("selectImports()")]),o._v("方法实现了自动配置的核心逻辑，主要包括以下步骤‌：")]),o._v(" "),e("ol",[e("li",[o._v("‌"),e("strong",[o._v("检查自动配置开关")]),o._v("‌：通过"),e("code",[o._v("isEnabled()")]),o._v("方法判断是否启用自动配置（默认开启，可通过配置"),e("code",[o._v("spring.boot.enableautoconfiguration")]),o._v("覆盖）‌。")]),o._v(" "),e("li",[o._v("‌"),e("strong",[o._v("加载候选配置类")]),o._v("‌：调用"),e("code",[o._v("getCandidateConfigurations()")]),o._v("从"),e("code",[o._v("META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports")]),o._v("（旧版本使用"),e("code",[o._v("META-INF/spring.factories")]),o._v("文件）中加载所有自动配置类‌。(SPI)")]),o._v(" "),e("li",[o._v("‌"),e("strong",[o._v("过滤与排序")]),o._v("‌：通过"),e("code",[o._v("removeDuplicates")]),o._v("去重、"),e("code",[o._v("getExclusions")]),o._v("排除类、"),e("code",[o._v("filter")]),o._v("条件过滤（如"),e("code",[o._v("@Conditional")]),o._v("注解）等步骤，最终确定生效的配置类‌。")]),o._v(" "),e("li",[o._v("‌"),e("strong",[o._v("返回配置类数组")]),o._v("‌：将过滤后的配置类全限定名数组返回，由Spring容器加载为Bean‌。")])]),o._v(" "),e("h3",{attrs:{id:"去重和排除机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#去重和排除机制"}},[o._v("#")]),o._v(" 去重和排除机制")]),o._v(" "),e("p",[o._v("在获取候选配置类后，Spring Boot会进行去重操作，并处理通过"),e("code",[o._v("@EnableAutoConfiguration")]),o._v("的"),e("code",[o._v("exclude")]),o._v("和"),e("code",[o._v("excludeName")]),o._v("属性排除的配置类。")]),o._v(" "),e("h3",{attrs:{id:"条件注解机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#条件注解机制"}},[o._v("#")]),o._v(" 条件注解机制")]),o._v(" "),e("p",[o._v("自动配置类通过"),e("code",[o._v("@Conditional")]),o._v("系列注解（如"),e("code",[o._v("@ConditionalOnClass")]),o._v("、"),e("code",[o._v("@ConditionalOnBean")]),o._v("等）动态决定是否生效‌。例如：")]),o._v(" "),e("ul",[e("li",[e("code",[o._v("@ConditionalOnClass")]),o._v("：检查类路径中是否存在指定类。")]),o._v(" "),e("li",[e("code",[o._v("@ConditionalOnMissingBean")]),o._v("：容器中不存在指定Bean时才生效。")])]),o._v(" "),e("p",[o._v("这些条件注解实现了“按需配置”，避免不必要的Bean注册‌。")]),o._v(" "),e("h3",{attrs:{id:"排序机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#排序机制"}},[o._v("#")]),o._v(" 排序机制")]),o._v(" "),e("p",[o._v("自动配置类可以通过"),e("code",[o._v("@AutoConfigureAfter")]),o._v("、"),e("code",[o._v("@AutoConfigureBefore")]),o._v("和@"),e("code",[o._v("AutoConfigureOrder")]),o._v("注解来控制加载顺序。调试时可以观察"),e("code",[o._v("AutoConfigurationImportSelector")]),o._v("中对配置类的排序逻辑。")])])}),[],!1,null,null,null);t.default=_.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{683:function(t,a,r){"use strict";r.r(a);var e=r(7),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"设计模式的六大原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的六大原则"}},[t._v("#")]),t._v(" 设计模式的六大原则")]),t._v(" "),r("h3",{attrs:{id:"开闭原则-open-close-principle"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#开闭原则-open-close-principle"}},[t._v("#")]),t._v(" 开闭原则（Open Close Principle）")]),t._v(" "),r("p",[t._v("开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，对接口编程而不是对实现编程。")]),t._v(" "),r("h3",{attrs:{id:"里氏代换原则-liskov-substitution-principle"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#里氏代换原则-liskov-substitution-principle"}},[t._v("#")]),t._v(" 里氏代换原则（Liskov Substitution Principle）")]),t._v(" "),r("p",[t._v("里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。")]),t._v(" "),r("h3",{attrs:{id:"依赖倒转原则-dependence-inversion-principle"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒转原则-dependence-inversion-principle"}},[t._v("#")]),t._v(" 依赖倒转原则（Dependence Inversion Principle）")]),t._v(" "),r("p",[t._v("这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。")]),t._v(" "),r("h3",{attrs:{id:"接口隔离原则-interface-segregation-principle"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则-interface-segregation-principle"}},[t._v("#")]),t._v(" 接口隔离原则（Interface Segregation Principle）")]),t._v(" "),r("p",[t._v("这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。")]),t._v(" "),r("h3",{attrs:{id:"迪米特法则-又称最少知道原则-demeter-principle"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#迪米特法则-又称最少知道原则-demeter-principle"}},[t._v("#")]),t._v(" 迪米特法则，又称最少知道原则（Demeter Principle）")]),t._v(" "),r("p",[t._v("最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。")]),t._v(" "),r("h3",{attrs:{id:"合成复用原则-composite-reuse-principle"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#合成复用原则-composite-reuse-principle"}},[t._v("#")]),t._v(" 合成复用原则（Composite Reuse Principle）")]),t._v(" "),r("p",[t._v("合成复用原则是指：尽量使用合成/聚合的方式，优先使用对象组合，而不是使用继承。")]),t._v(" "),r("h2",{attrs:{id:"设计模式的三大分类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的三大分类"}},[t._v("#")]),t._v(" 设计模式的三大分类")]),t._v(" "),r("h3",{attrs:{id:"创建型模式-creational-patterns"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建型模式-creational-patterns"}},[t._v("#")]),t._v(" 创建型模式（Creational Patterns）")]),t._v(" "),r("p",[t._v("这些模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。")]),t._v(" "),r("h4",{attrs:{id:"单例模式-singleton-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单例模式-singleton-pattern"}},[t._v("#")]),t._v(" 单例模式（Singleton Pattern）")]),t._v(" "),r("h4",{attrs:{id:"原型模式-prototype-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原型模式-prototype-pattern"}},[t._v("#")]),t._v(" 原型模式（Prototype Pattern）")]),t._v(" "),r("h4",{attrs:{id:"建造者模式-builder-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#建造者模式-builder-pattern"}},[t._v("#")]),t._v(" 建造者模式（Builder Pattern）")]),t._v(" "),r("h4",{attrs:{id:"简单工厂模式-simple-factory-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简单工厂模式-simple-factory-pattern"}},[t._v("#")]),t._v(" 简单工厂模式（Simple Factory Pattern）")]),t._v(" "),r("h4",{attrs:{id:"抽象工厂模式-abstract-factory-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#抽象工厂模式-abstract-factory-pattern"}},[t._v("#")]),t._v(" 抽象工厂模式（Abstract Factory Pattern）")]),t._v(" "),r("h4",{attrs:{id:"工厂方法模式-factory-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#工厂方法模式-factory-pattern"}},[t._v("#")]),t._v(" 工厂方法模式（Factory Pattern）")]),t._v(" "),r("h3",{attrs:{id:"结构型模式-structural-patterns"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#结构型模式-structural-patterns"}},[t._v("#")]),t._v(" 结构型模式（Structural Patterns）")]),t._v(" "),r("p",[t._v("这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。")]),t._v(" "),r("h4",{attrs:{id:"享元模式-flyweight-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#享元模式-flyweight-pattern"}},[t._v("#")]),t._v(" 享元模式（Flyweight Pattern）")]),t._v(" "),r("h4",{attrs:{id:"外观模式-facade-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#外观模式-facade-pattern"}},[t._v("#")]),t._v(" 外观模式（Facade Pattern）")]),t._v(" "),r("h4",{attrs:{id:"桥接模式-bridge-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#桥接模式-bridge-pattern"}},[t._v("#")]),t._v(" 桥接模式（Bridge Pattern）")]),t._v(" "),r("h4",{attrs:{id:"组合模式-composite-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#组合模式-composite-pattern"}},[t._v("#")]),t._v(" 组合模式（Composite Pattern）")]),t._v(" "),r("h4",{attrs:{id:"代理模式-proxy-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#代理模式-proxy-pattern"}},[t._v("#")]),t._v(" 代理模式（Proxy Pattern）")]),t._v(" "),r("h4",{attrs:{id:"适配器模式-adapter-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式-adapter-pattern"}},[t._v("#")]),t._v(" 适配器模式（Adapter Pattern）")]),t._v(" "),r("h4",{attrs:{id:"过滤器模式-filter、criteria-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#过滤器模式-filter、criteria-pattern"}},[t._v("#")]),t._v(" 过滤器模式（Filter、Criteria Pattern）")]),t._v(" "),r("h4",{attrs:{id:"装饰器模式-decorator-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#装饰器模式-decorator-pattern"}},[t._v("#")]),t._v(" 装饰器模式（Decorator Pattern）")]),t._v(" "),r("h3",{attrs:{id:"行为型模式-behavioral-patterns"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#行为型模式-behavioral-patterns"}},[t._v("#")]),t._v(" 行为型模式（Behavioral Patterns）")]),t._v(" "),r("p",[t._v("这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。")]),t._v(" "),r("h4",{attrs:{id:"策略模式-strategy-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#策略模式-strategy-pattern"}},[t._v("#")]),t._v(" 策略模式（Strategy Pattern）")]),t._v(" "),r("h4",{attrs:{id:"状态模式-state-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#状态模式-state-pattern"}},[t._v("#")]),t._v(" 状态模式（State Pattern）")]),t._v(" "),r("h4",{attrs:{id:"命令模式-command-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#命令模式-command-pattern"}},[t._v("#")]),t._v(" 命令模式（Command Pattern）")]),t._v(" "),r("h4",{attrs:{id:"观察者模式-observer-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式-observer-pattern"}},[t._v("#")]),t._v(" 观察者模式（Observer Pattern）")]),t._v(" "),r("h4",{attrs:{id:"访问者模式-visitor-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#访问者模式-visitor-pattern"}},[t._v("#")]),t._v(" 访问者模式（Visitor Pattern）")]),t._v(" "),r("h4",{attrs:{id:"中介者模式-mediator-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#中介者模式-mediator-pattern"}},[t._v("#")]),t._v(" 中介者模式（Mediator Pattern）")]),t._v(" "),r("h4",{attrs:{id:"迭代器模式-iterator-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#迭代器模式-iterator-pattern"}},[t._v("#")]),t._v(" 迭代器模式（Iterator Pattern）")]),t._v(" "),r("h4",{attrs:{id:"责任链模式-chain-of-responsibility-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#责任链模式-chain-of-responsibility-pattern"}},[t._v("#")]),t._v(" 责任链模式（Chain of Responsibility Pattern）")]),t._v(" "),r("h4",{attrs:{id:"备忘录模式-memento-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#备忘录模式-memento-pattern"}},[t._v("#")]),t._v(" 备忘录模式（Memento Pattern）")]),t._v(" "),r("h4",{attrs:{id:"解释器模式-interpreter-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#解释器模式-interpreter-pattern"}},[t._v("#")]),t._v(" 解释器模式（Interpreter Pattern）")]),t._v(" "),r("h4",{attrs:{id:"空对象模式-null-object-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#空对象模式-null-object-pattern"}},[t._v("#")]),t._v(" 空对象模式（Null Object Pattern）")]),t._v(" "),r("h4",{attrs:{id:"模板方法模式-template-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模板方法模式-template-pattern"}},[t._v("#")]),t._v(" 模板方法模式（Template Pattern）")]),t._v(" "),r("h2",{attrs:{id:"设计模式的uml类图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的uml类图"}},[t._v("#")]),t._v(" 设计模式的UML类图")]),t._v(" "),r("p",[t._v("类图（Class Diagram）是面向对象系统建模中最常用和最重要的图。\n类图主要用在面向对象软件开发的分析和设计阶段，描述系统的静态结构。\n类图展示了所构建系统的所有实体、实体的内部结构以及实体之间的关系。\n类图是定义其它图的基础，没有类图，就没有对象图、状态图、协作图等其他UML图。\n类图也是面向对象编程的起点和依据。")]),t._v(" "),r("p",[t._v("**类图（Class Diagram）一般包含3个组成部分。**第一个是类名；第二个是特性（字段或属性）；第三个是操作（方法或行为）；第四个是类的性质；第五个是内部类。类名不能省略，其他部分可省。")]),t._v(" "),r("p",[r("strong",[t._v("类名书写规范")]),t._v("：正体字说明类是可被实例化的，斜体字说明类为抽象类。")]),t._v(" "),r("p",[r("strong",[t._v("属性书写规范")]),t._v("：修饰符 [描述信息] 属性")]),t._v(" "),r("p",[r("strong",[t._v("方法书写规范")]),t._v("：修饰符 方法名称 [参数] [：返回类型|类型]。")]),t._v(" "),r("p",[t._v("属性和方法之前可附加的可见性修饰符："),r("strong",[t._v("加号（+）表示public；减号（-）表示private；井号（#）表示protected")]),t._v("；省略这些修饰符表示具有package（包）级别的可见性。")]),t._v(" "),r("p",[t._v("如果属性或方法具有下划线，则说明它是静态的。")]),t._v(" "),r("p",[t._v("描述信息使用 << 开头，使用 >> 结尾。")]),t._v(" "),r("p",[r("strong",[t._v("常见的关系有：继承/泛化（Inheritance/Generalization），实现关系（Realization/Implementation），关联关系（Association），聚合关系（Aggregation），合成/组合/复合关系（Composition），依赖关系（Dependency）。")])]),t._v(" "),r("p",[r("strong",[t._v("一般化关系（is a / a kind of）")]),t._v("：表示为类与类之间的继承关系，接口与接口之间的继承，类对接口的实现关系。\n"),r("strong",[t._v("继承/泛化（Inheritance/Generalization）")]),t._v("：表示为类与类之间的继承关系，接口与接口之间的继承。\n符合表示： 空心三角形+实线，箭头指向父类。\n"),r("strong",[t._v("实现关系（Realization/Implementation）")]),t._v("：类对接口的实现关系。\n符合表示： 空心三角形+虚线，箭头指向接口。")]),t._v(" "),r("p",[r("strong",[t._v("关联关系（Association）")]),t._v("：模型元素之间的一种语义联系，是类之间的一种很弱的联系。类与类之间的联接，当一个类知道另一个类时可以使用关联关系，它使一个类知道另一个类的属性和方法。关联可以有方向，可以是单向关联，也可以是双向关联。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。\n代码表现：成员变量/全局变量。\n符合表示：实线+箭头， 箭头指向被使用的类。")]),t._v(" "),r("p",[r("strong",[t._v("聚合关系（Aggregation）（has a）")]),t._v("：是关联关系的一种, 是强的关联关系。聚合关系是整体与部分的关系，部分可以离开整体而单独存在，他们可以具有各自的生命周期，部分可以属于多个整体，也可以为多个整体共享，表示一种弱的‘拥有’关系。需求描述中“包含”、“组成”、“分为….部分”等词常意味着聚合关系。\n代码表现：成员变量/全局变量。\n符合表示：空心菱形+实线+箭头，箭头指向部分，菱形指向整体。")]),t._v(" "),r("p",[r("strong",[t._v("合成/组合/复合关系（Composition）（contains a）")]),t._v("：是关联关系的一种，是比聚合关系还要强的关系，也称为强聚合。组合关系也表示类之间整体和部分的关系，但是组合关系中部分和整体的生存周期一样，整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束，表示一种强的‘拥有’关系。\n代码表现：成员变量/全局变量。\n符合表示：实心菱形+实线+箭头，箭头指向部分，菱形指向整体。")]),t._v(" "),r("p",[r("strong",[t._v("依赖关系（Dependency）（use a）")]),t._v("：是一种使用的关系，即一个类的实现需要另一个类的协助。\n代码表现：局部变量、方法的参数或者对静态方法的调用。\n符合表示：虚线+箭头，箭头指向被依赖的一方，也就是指向局部变量。")]),t._v(" "),r("p",[r("strong",[t._v("各种关系的强弱顺序：泛化=实现>组合>聚合>关联>依赖")])]),t._v(" "),r("h2",{attrs:{id:"相关链接"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#相关链接"}},[t._v("#")]),t._v(" 相关链接")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://www.runoob.com/design-pattern/design-pattern-tutorial.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.runoob.com/design-pattern/design-pattern-tutorial.html"),r("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=s.exports}}]);